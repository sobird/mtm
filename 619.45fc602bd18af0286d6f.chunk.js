"use strict";(window.webpackJsonp_mtm=window.webpackJsonp_mtm||[]).push([[619],{80521:(pe,x,v)=>{v.d(x,{Z:()=>B});var g=v(87462),J=v(67294),W={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M744 62H280c-35.3 0-64 28.7-64 64v768c0 35.3 28.7 64 64 64h464c35.3 0 64-28.7 64-64V126c0-35.3-28.7-64-64-64zm-8 824H288V134h448v752zM472 784a40 40 0 1080 0 40 40 0 10-80 0z"}}]},name:"mobile",theme:"outlined"};const C=W;var L=v(30076),H=function(F,$){return J.createElement(L.Z,(0,g.Z)({},F,{ref:$,icon:C}))};const B=J.forwardRef(H)},98724:(pe,x,v)=>{v.d(x,{N6:()=>Qe});const g=new TextEncoder,J=new TextDecoder,W=null;function C(...e){const t=e.reduce((a,{length:i})=>a+i,0),r=new Uint8Array(t);let n=0;return e.forEach(a=>{r.set(a,n),n+=a.length}),r}function L(e,t){return C(g.encode(e),new Uint8Array([0]),t)}function H(e,t,r){if(t<0||t>=W)throw new RangeError(`value must be >= 0 and <= ${W-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,t&255],r)}function B(e){const t=Math.floor(e/W),r=e%W,n=new Uint8Array(8);return H(n,t,0),H(n,r,4),n}function R(e){const t=new Uint8Array(4);return H(t,e),t}function F(e){return C(R(e.length),e)}async function $(e,t,r){const n=Math.ceil((t>>3)/32),a=new Uint8Array(n*32);for(let i=0;i<n;i++){const s=new Uint8Array(4+e.length+r.length);s.set(R(i+1)),s.set(e,4),s.set(r,4+e.length),a.set(await digest("sha256",s),i*32)}return a.slice(0,t>>3)}const he=e=>{let t=e;typeof t=="string"&&(t=g.encode(t));const r=32768,n=[];for(let a=0;a<t.length;a+=r)n.push(String.fromCharCode.apply(null,t.subarray(a,a+r)));return btoa(n.join(""))},P=e=>he(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),ye=e=>{const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r},fe=e=>{let t=e;t instanceof Uint8Array&&(t=J.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return ye(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class U extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(t){var r;super(t),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(r=Error.captureStackTrace)===null||r===void 0||r.call(Error,this,this.constructor)}}class ot extends null{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(t,r="unspecified",n="unspecified"){super(t),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=r,this.reason=n}}class ct extends null{static get code(){return"ERR_JWT_EXPIRED"}constructor(t,r="unspecified",n="unspecified"){super(t),this.code="ERR_JWT_EXPIRED",this.claim=r,this.reason=n}}class dt extends null{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class G extends U{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class lt extends null{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class ut extends null{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class I extends U{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class we extends U{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class pt extends null{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}static get code(){return"ERR_JWK_INVALID"}}class ht extends null{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}}class yt extends null{constructor(){super(...arguments),this.code="ERR_JWKS_NO_MATCHING_KEY",this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}}class ft extends null{constructor(){super(...arguments),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS",this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}class wt extends null{constructor(){super(...arguments),this.code="ERR_JWKS_TIMEOUT",this.message="request timed out"}static get code(){return"ERR_JWKS_TIMEOUT"}}class mt extends null{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}const T=crypto,V=e=>e instanceof CryptoKey,Et=T.getRandomValues.bind(T);function me(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new JOSENotSupported(`Unsupported JWE Algorithm: ${e}`)}}const St=e=>random(new Uint8Array(me(e)>>3)),gt=(e,t)=>{if(t.length<<3!==bitLength(e))throw new JWEInvalid("Invalid Initialization Vector length")},_t=null,bt=(e,t)=>{const r=e.byteLength<<3;if(r!==t)throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)},At=null;async function Ee(e,t,r,n,a,i){if(!(t instanceof Uint8Array))throw new TypeError(invalidKeyInput(t,"Uint8Array"));const s=parseInt(e.slice(1,4),10),o=await crypto.subtle.importKey("raw",t.subarray(s>>3),"AES-CBC",!1,["decrypt"]),d=await crypto.subtle.importKey("raw",t.subarray(0,s>>3),{hash:`SHA-${s<<1}`,name:"HMAC"},!1,["sign"]),c=concat(i,n,r,uint64be(i.length<<3)),l=new Uint8Array((await crypto.subtle.sign("HMAC",d,c)).slice(0,s>>3));let u;try{u=timingSafeEqual(a,l)}catch{}if(!u)throw new JWEDecryptionFailed;let p;try{p=new Uint8Array(await crypto.subtle.decrypt({iv:n,name:"AES-CBC"},o,r))}catch{}if(!p)throw new JWEDecryptionFailed;return p}async function Se(e,t,r,n,a,i){let s;t instanceof Uint8Array?s=await crypto.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(checkEncCryptoKey(t,e,"decrypt"),s=t);try{return new Uint8Array(await crypto.subtle.decrypt({additionalData:i,iv:n,name:"AES-GCM",tagLength:128},s,concat(r,a)))}catch{throw new JWEDecryptionFailed}}const vt=async(e,t,r,n,a,i)=>{if(!isCryptoKey(t)&&!(t instanceof Uint8Array))throw new TypeError(invalidKeyInput(t,...types,"Uint8Array"));switch(checkIvLength(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&checkCekLength(t,parseInt(e.slice(-3),10)),Ee(e,t,r,n,a,i);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&checkCekLength(t,parseInt(e.slice(1,4),10)),Se(e,t,r,n,a,i);default:throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm")}},Jt=null,Wt=async()=>{throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.')},Kt=async()=>{throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.')},Ct=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]],Ht=null;function z(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function X(e,t,r){if(isCryptoKey(e))return checkEncCryptoKey(e,t,r),e;if(e instanceof Uint8Array)return crypto.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(invalidKeyInput(e,...types,"Uint8Array"))}const It=async(e,t,r)=>{const n=await X(t,e,"wrapKey");z(n,e);const a=await crypto.subtle.importKey("raw",r,...bogusWebCrypto);return new Uint8Array(await crypto.subtle.wrapKey("raw",a,n,"AES-KW"))},Pt=async(e,t,r)=>{const n=await X(t,e,"unwrapKey");z(n,e);const a=await crypto.subtle.unwrapKey("raw",r,n,"AES-KW",...bogusWebCrypto);return new Uint8Array(await crypto.subtle.exportKey("raw",a))};async function Tt(e,t,r,n,a=new Uint8Array(0),i=new Uint8Array(0)){if(!isCryptoKey(e))throw new TypeError(invalidKeyInput(e,...types));if(checkEncCryptoKey(e,"ECDH"),!isCryptoKey(t))throw new TypeError(invalidKeyInput(t,...types));checkEncCryptoKey(t,"ECDH","deriveBits");const s=concat(lengthAndInput(encoder.encode(r)),lengthAndInput(a),lengthAndInput(i),uint32be(n));let o;e.algorithm.name==="X25519"?o=256:e.algorithm.name==="X448"?o=448:o=Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;const d=new Uint8Array(await crypto.subtle.deriveBits({name:e.algorithm.name,public:e},t,o));return concatKdf(d,n,s)}async function Ot(e){if(!isCryptoKey(e))throw new TypeError(invalidKeyInput(e,...types));return crypto.subtle.generateKey(e.algorithm,!0,["deriveBits"])}function xt(e){if(!isCryptoKey(e))throw new TypeError(invalidKeyInput(e,...types));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||e.algorithm.name==="X25519"||e.algorithm.name==="X448"}function Rt(e){if(!(e instanceof Uint8Array)||e.length<8)throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets")}function ge(e,t){if(e instanceof Uint8Array)return crypto.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(isCryptoKey(e))return checkEncCryptoKey(e,t,"deriveBits","deriveKey"),e;throw new TypeError(invalidKeyInput(e,...types,"Uint8Array"))}async function Y(e,t,r,n){checkP2s(e);const a=concatSalt(t,e),i=parseInt(t.slice(13,16),10),s={hash:`SHA-${t.slice(8,11)}`,iterations:r,name:"PBKDF2",salt:a},o={length:i,name:"AES-KW"},d=await ge(n,t);if(d.usages.includes("deriveBits"))return new Uint8Array(await crypto.subtle.deriveBits(s,d,i));if(d.usages.includes("deriveKey"))return crypto.subtle.deriveKey(s,d,o,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}const Ut=async(e,t,r,n=2048,a=random(new Uint8Array(16)))=>{const i=await Y(a,e,n,t);return{encryptedKey:await wrap(e.slice(-6),i,r),p2c:n,p2s:base64url(a)}},Dt=async(e,t,r,n,a)=>{const i=await Y(a,e,n,t);return unwrap(e.slice(-6),i,r)};function Mt(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new JOSENotSupported(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}const kt=async(e,t,r)=>{if(!isCryptoKey(t))throw new TypeError(invalidKeyInput(t,...types));if(checkEncCryptoKey(t,e,"encrypt","wrapKey"),checkKeyLength(e,t),t.usages.includes("encrypt"))return new Uint8Array(await crypto.subtle.encrypt(subtleAlgorithm(e),t,r));if(t.usages.includes("wrapKey")){const n=await crypto.subtle.importKey("raw",r,...bogusWebCrypto);return new Uint8Array(await crypto.subtle.wrapKey("raw",n,t,subtleAlgorithm(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')},Nt=async(e,t,r)=>{if(!isCryptoKey(t))throw new TypeError(invalidKeyInput(t,...types));if(checkEncCryptoKey(t,e,"decrypt","unwrapKey"),checkKeyLength(e,t),t.usages.includes("decrypt"))return new Uint8Array(await crypto.subtle.decrypt(subtleAlgorithm(e),t,r));if(t.usages.includes("unwrapKey")){const n=await crypto.subtle.unwrapKey("raw",r,t,subtleAlgorithm(e),...bogusWebCrypto);return new Uint8Array(await crypto.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function _e(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new JOSENotSupported(`Unsupported JWE Algorithm: ${e}`)}}const Lt=e=>random(new Uint8Array(_e(e)>>3)),Z=async(e,t,r)=>{if(!isCryptoKey(r))throw new TypeError(invalidKeyInput(r,...types));if(!r.extractable)throw new TypeError("CryptoKey is not extractable");if(r.type!==e)throw new TypeError(`key is not a ${e} key`);return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(t,r))),`${e.toUpperCase()} KEY`)},Bt=e=>Z("public","spki",e),Ft=e=>Z("private","pkcs8",e),_=(e,t,r=0)=>{r===0&&(t.unshift(t.length),t.unshift(6));let n=e.indexOf(t[0],r);if(n===-1)return!1;const a=e.subarray(n,n+t.length);return a.length!==t.length?!1:a.every((i,s)=>i===t[s])||_(e,t,n+1)},q=e=>{switch(!0){case _(e,[42,134,72,206,61,3,1,7]):return"P-256";case _(e,[43,129,4,0,34]):return"P-384";case _(e,[43,129,4,0,35]):return"P-521";case _(e,[43,101,110]):return"X25519";case _(e,[43,101,111]):return"X448";case _(e,[43,101,112]):return"Ed25519";case _(e,[43,101,113]):return"Ed448";default:throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type")}},Q=async(e,t,r,n,a)=>{var i;let s,o;const d=new Uint8Array(atob(r.replace(e,"")).split("").map(l=>l.charCodeAt(0))),c=t==="spki";switch(n){case"PS256":case"PS384":case"PS512":s={name:"RSA-PSS",hash:`SHA-${n.slice(-3)}`},o=c?["verify"]:["sign"];break;case"RS256":case"RS384":case"RS512":s={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${n.slice(-3)}`},o=c?["verify"]:["sign"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":s={name:"RSA-OAEP",hash:`SHA-${parseInt(n.slice(-3),10)||1}`},o=c?["encrypt","wrapKey"]:["decrypt","unwrapKey"];break;case"ES256":s={name:"ECDSA",namedCurve:"P-256"},o=c?["verify"]:["sign"];break;case"ES384":s={name:"ECDSA",namedCurve:"P-384"},o=c?["verify"]:["sign"];break;case"ES512":s={name:"ECDSA",namedCurve:"P-521"},o=c?["verify"]:["sign"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{const l=q(d);s=l.startsWith("P-")?{name:"ECDH",namedCurve:l}:{name:l},o=c?[]:["deriveBits"];break}case"EdDSA":s={name:q(d)},o=c?["verify"]:["sign"];break;default:throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value')}return crypto.subtle.importKey(t,d,s,(i=a?.extractable)!==null&&i!==void 0?i:!1,o)},$t=(e,t,r)=>Q(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,"pkcs8",e,t,r),be=(e,t,r)=>Q(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",e,t,r);function j(e){let t=[],r=0;for(;r<e.length;){let n=ee(e.subarray(r));t.push(n),r+=n.byteLength}return t}function ee(e){let t=0,r=e[0]&31;if(t++,r===31){for(r=0;e[t]>=128;)r=r*128+e[t]-128,t++;r=r*128+e[t]-128,t++}let n=0;if(e[t]<128)n=e[t],t++;else if(n===128){for(n=0;e[t+n]!==0||e[t+n+1]!==0;){if(n>e.byteLength)throw new TypeError("invalid indefinite form length");n++}const i=t+n+2;return{byteLength:i,contents:e.subarray(t,t+n),raw:e.subarray(0,i)}}else{let i=e[t]&127;t++,n=0;for(let s=0;s<i;s++)n=n*256+e[t],t++}const a=t+n;return{byteLength:a,contents:e.subarray(t,a),raw:e.subarray(0,a)}}function Ae(e){const t=j(j(ee(e).contents)[0].contents);return encodeBase64(t[t[0].raw[0]===160?6:5].raw)}function ve(e){const t=e.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g,""),r=decodeBase64(t);return formatPEM(Ae(r),"PUBLIC KEY")}const Gt=(e,t,r)=>{let n;try{n=ve(e)}catch(a){throw new TypeError("Failed to parse the X.509 certificate",{cause:a})}return be(n,t,r)};function Je(e){let t,r;switch(e.kty){case"oct":{switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.slice(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new JOSENotSupported(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}const Vt=async e=>{var t,r;if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:n,keyUsages:a}=Je(e),i=[n,(t=e.ext)!==null&&t!==void 0?t:!1,(r=e.key_ops)!==null&&r!==void 0?r:a];if(n.name==="PBKDF2")return crypto.subtle.importKey("raw",base64url(e.k),...i);const s={...e};return delete s.alg,delete s.use,crypto.subtle.importKey("jwk",s,...i)},zt=null;async function Xt(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PUBLIC KEY-----")!==0)throw new TypeError('"spki" must be SPKI formatted string');return fromSPKI(e,t,r)}async function Yt(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN CERTIFICATE-----")!==0)throw new TypeError('"x509" must be X.509 formatted string');return fromX509(e,t,r)}async function Zt(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PRIVATE KEY-----")!==0)throw new TypeError('"pkcs8" must be PKCS#8 formatted string');return fromPKCS8(e,t,r)}async function qt(e,t,r){var n;if(!isObject(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if(typeof e.k!="string"||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return r??(r=e.ext!==!0),r?asKeyObject({...e,alg:t,ext:(n=e.ext)!==null&&n!==void 0?n:!1}):decodeBase64URL(e.k);case"RSA":if(e.oth!==void 0)throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return asKeyObject({...e,alg:t});default:throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value')}}async function We(e,t,r,n,a){if(!(r instanceof Uint8Array))throw new TypeError(invalidKeyInput(r,"Uint8Array"));const i=parseInt(e.slice(1,4),10),s=await crypto.subtle.importKey("raw",r.subarray(i>>3),"AES-CBC",!1,["encrypt"]),o=await crypto.subtle.importKey("raw",r.subarray(0,i>>3),{hash:`SHA-${i<<1}`,name:"HMAC"},!1,["sign"]),d=new Uint8Array(await crypto.subtle.encrypt({iv:n,name:"AES-CBC"},s,t)),c=concat(a,n,d,uint64be(a.length<<3)),l=new Uint8Array((await crypto.subtle.sign("HMAC",o,c)).slice(0,i>>3));return{ciphertext:d,tag:l}}async function Ke(e,t,r,n,a){let i;r instanceof Uint8Array?i=await crypto.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(checkEncCryptoKey(r,e,"encrypt"),i=r);const s=new Uint8Array(await crypto.subtle.encrypt({additionalData:a,iv:n,name:"AES-GCM",tagLength:128},i,t)),o=s.slice(-16);return{ciphertext:s.slice(0,-16),tag:o}}const Qt=async(e,t,r,n,a)=>{if(!isCryptoKey(r)&&!(r instanceof Uint8Array))throw new TypeError(invalidKeyInput(r,...types,"Uint8Array"));switch(checkIvLength(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r instanceof Uint8Array&&checkCekLength(r,parseInt(e.slice(-3),10)),We(e,t,r,n,a);case"A128GCM":case"A192GCM":case"A256GCM":return r instanceof Uint8Array&&checkCekLength(r,parseInt(e.slice(1,4),10)),Ke(e,t,r,n,a);default:throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm")}},jt=null;async function er(e,t,r,n){const a=e.slice(0,7);n||(n=generateIv(a));const{ciphertext:i,tag:s}=await encrypt(a,r,t,n,new Uint8Array(0));return{encryptedKey:i,iv:base64url(n),tag:base64url(s)}}async function tr(e,t,r,n,a){const i=e.slice(0,7);return decrypt(i,t,r,n,a,new Uint8Array(0))}async function rr(e,t,r,n,a){switch(checkKeyType(e,t,"decrypt"),e){case"dir":{if(r!==void 0)throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");return t}case"ECDH-ES":if(r!==void 0)throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!isObject(n.epk))throw new JWEInvalid('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!ECDH.ecdhAllowed(t))throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");const i=await importJWK(n.epk,e);let s,o;if(n.apu!==void 0){if(typeof n.apu!="string")throw new JWEInvalid('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{s=base64url(n.apu)}catch{throw new JWEInvalid("Failed to base64url decode the apu")}}if(n.apv!==void 0){if(typeof n.apv!="string")throw new JWEInvalid('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{o=base64url(n.apv)}catch{throw new JWEInvalid("Failed to base64url decode the apv")}}const d=await ECDH.deriveKey(i,t,e==="ECDH-ES"?n.enc:e,e==="ECDH-ES"?cekLength(n.enc):parseInt(e.slice(-5,-2),10),s,o);if(e==="ECDH-ES")return d;if(r===void 0)throw new JWEInvalid("JWE Encrypted Key missing");return aesKw(e.slice(-6),d,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(r===void 0)throw new JWEInvalid("JWE Encrypted Key missing");return rsaEs(e,t,r)}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(r===void 0)throw new JWEInvalid("JWE Encrypted Key missing");if(typeof n.p2c!="number")throw new JWEInvalid('JOSE Header "p2c" (PBES2 Count) missing or invalid');const i=a?.maxPBES2Count||1e4;if(n.p2c>i)throw new JWEInvalid('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if(typeof n.p2s!="string")throw new JWEInvalid('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let s;try{s=base64url(n.p2s)}catch{throw new JWEInvalid("Failed to base64url decode the p2s")}return pbes2Kw(e,t,r,n.p2c,s)}case"A128KW":case"A192KW":case"A256KW":{if(r===void 0)throw new JWEInvalid("JWE Encrypted Key missing");return aesKw(e,t,r)}case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(r===void 0)throw new JWEInvalid("JWE Encrypted Key missing");if(typeof n.iv!="string")throw new JWEInvalid('JOSE Header "iv" (Initialization Vector) missing or invalid');if(typeof n.tag!="string")throw new JWEInvalid('JOSE Header "tag" (Authentication Tag) missing or invalid');let i;try{i=base64url(n.iv)}catch{throw new JWEInvalid("Failed to base64url decode the iv")}let s;try{s=base64url(n.tag)}catch{throw new JWEInvalid("Failed to base64url decode the tag")}return aesGcmKw(e,t,r,i,s)}default:throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value')}}const nr=null;function Ce(e,t,r,n,a){if(a.crit!==void 0&&n.crit===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(s=>typeof s!="string"||s.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;r!==void 0?i=new Map([...Object.entries(r),...t.entries()]):i=t;for(const s of n.crit){if(!i.has(s))throw new G(`Extension Header Parameter "${s}" is not recognized`);if(a[s]===void 0)throw new e(`Extension Header Parameter "${s}" is missing`);if(i.get(s)&&n[s]===void 0)throw new e(`Extension Header Parameter "${s}" MUST be integrity protected`)}return new Set(n.crit)}const He=Ce;async function ar(e,t,r){var n;if(!isObject(e))throw new JWEInvalid("Flattened JWE must be an object");if(e.protected===void 0&&e.header===void 0&&e.unprotected===void 0)throw new JWEInvalid("JOSE Header missing");if(typeof e.iv!="string")throw new JWEInvalid("JWE Initialization Vector missing or incorrect type");if(typeof e.ciphertext!="string")throw new JWEInvalid("JWE Ciphertext missing or incorrect type");if(typeof e.tag!="string")throw new JWEInvalid("JWE Authentication Tag missing or incorrect type");if(e.protected!==void 0&&typeof e.protected!="string")throw new JWEInvalid("JWE Protected Header incorrect type");if(e.encrypted_key!==void 0&&typeof e.encrypted_key!="string")throw new JWEInvalid("JWE Encrypted Key incorrect type");if(e.aad!==void 0&&typeof e.aad!="string")throw new JWEInvalid("JWE AAD incorrect type");if(e.header!==void 0&&!isObject(e.header))throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");if(e.unprotected!==void 0&&!isObject(e.unprotected))throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");let a;if(e.protected)try{const m=base64url(e.protected);a=JSON.parse(decoder.decode(m))}catch{throw new JWEInvalid("JWE Protected Header is invalid")}if(!isDisjoint(a,e.header,e.unprotected))throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const i={...a,...e.header,...e.unprotected};if(validateCrit(JWEInvalid,new Map,r?.crit,a,i),i.zip!==void 0){if(!a||!a.zip)throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if(i.zip!=="DEF")throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:s,enc:o}=i;if(typeof s!="string"||!s)throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");if(typeof o!="string"||!o)throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");const d=r&&validateAlgorithms("keyManagementAlgorithms",r.keyManagementAlgorithms),c=r&&validateAlgorithms("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(d&&!d.has(s))throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');if(c&&!c.has(o))throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');let l;if(e.encrypted_key!==void 0)try{l=base64url(e.encrypted_key)}catch{throw new JWEInvalid("Failed to base64url decode the encrypted_key")}let u=!1;typeof t=="function"&&(t=await t(a,e),u=!0);let p;try{p=await decryptKeyManagement(s,t,l,i,r)}catch(m){if(m instanceof TypeError||m instanceof JWEInvalid||m instanceof JOSENotSupported)throw m;p=generateCek(o)}let h,y;try{h=base64url(e.iv)}catch{throw new JWEInvalid("Failed to base64url decode the iv")}try{y=base64url(e.tag)}catch{throw new JWEInvalid("Failed to base64url decode the tag")}const f=encoder.encode((n=e.protected)!==null&&n!==void 0?n:"");let S;e.aad!==void 0?S=concat(f,encoder.encode("."),encoder.encode(e.aad)):S=f;let ue;try{ue=base64url(e.ciphertext)}catch{throw new JWEInvalid("Failed to base64url decode the ciphertext")}let N=await decrypt(o,p,ue,h,y,S);i.zip==="DEF"&&(N=await(r?.inflateRaw||inflate)(N));const K={plaintext:N};if(e.protected!==void 0&&(K.protectedHeader=a),e.aad!==void 0)try{K.additionalAuthenticatedData=base64url(e.aad)}catch{throw new JWEInvalid("Failed to base64url decode the aad")}return e.unprotected!==void 0&&(K.sharedUnprotectedHeader=e.unprotected),e.header!==void 0&&(K.unprotectedHeader=e.header),u?{...K,key:t}:K}async function ir(e,t,r){if(e instanceof Uint8Array&&(e=decoder.decode(e)),typeof e!="string")throw new JWEInvalid("Compact JWE must be a string or Uint8Array");const{0:n,1:a,2:i,3:s,4:o,length:d}=e.split(".");if(d!==5)throw new JWEInvalid("Invalid Compact JWE");const c=await flattenedDecrypt({ciphertext:s,iv:i||void 0,protected:n||void 0,tag:o||void 0,encrypted_key:a||void 0},t,r),l={plaintext:c.plaintext,protectedHeader:c.protectedHeader};return typeof t=="function"?{...l,key:c.key}:l}async function sr(e,t,r){if(!isObject(e))throw new JWEInvalid("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(isObject))throw new JWEInvalid("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new JWEInvalid("JWE Recipients has no members");for(const n of e.recipients)try{return await flattenedDecrypt({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:n.encrypted_key,header:n.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch{}throw new JWEDecryptionFailed}const or=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:base64url(e)};if(!isCryptoKey(e))throw new TypeError(invalidKeyInput(e,...types,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:r,alg:n,use:a,...i}=await crypto.subtle.exportKey("jwk",e);return i},cr=null;async function dr(e){return exportPublic(e)}async function lr(e){return exportPrivate(e)}async function ur(e){return keyToJWK(e)}async function pr(e,t,r,n,a={}){let i,s,o;switch(checkKeyType(e,r,"encrypt"),e){case"dir":{o=r;break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ECDH.ecdhAllowed(r))throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:d,apv:c}=a;let{epk:l}=a;l||(l=(await ECDH.generateEpk(r)).privateKey);const{x:u,y:p,crv:h,kty:y}=await exportJWK(l),f=await ECDH.deriveKey(r,l,e==="ECDH-ES"?t:e,e==="ECDH-ES"?cekLength(t):parseInt(e.slice(-5,-2),10),d,c);if(s={epk:{x:u,crv:h,kty:y}},y==="EC"&&(s.epk.y=p),d&&(s.apu=base64url(d)),c&&(s.apv=base64url(c)),e==="ECDH-ES"){o=f;break}o=n||generateCek(t);const S=e.slice(-6);i=await aesKw(S,f,o);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{o=n||generateCek(t),i=await rsaEs(e,r,o);break}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{o=n||generateCek(t);const{p2c:d,p2s:c}=a;({encryptedKey:i,...s}=await pbes2Kw(e,r,o,d,c));break}case"A128KW":case"A192KW":case"A256KW":{o=n||generateCek(t),i=await aesKw(e,r,o);break}case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{o=n||generateCek(t);const{iv:d}=a;({encryptedKey:i,...s}=await aesGcmKw(e,r,o,d));break}default:throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:o,encryptedKey:i,parameters:s}}const hr=null,Ie=Symbol();class yr{constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=t}setKeyManagementParameters(t){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=t,this}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setSharedUnprotectedHeader(t){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}setAdditionalAuthenticatedData(t){return this._aad=t,this}setContentEncryptionKey(t){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=t,this}setInitializationVector(t){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=t,this}async encrypt(t,r){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!isDisjoint(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const n={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(validateCrit(JWEInvalid,new Map,r?.crit,this._protectedHeader,n),n.zip!==void 0){if(!this._protectedHeader||!this._protectedHeader.zip)throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if(n.zip!=="DEF")throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:a,enc:i}=n;if(typeof a!="string"||!a)throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(typeof i!="string"||!i)throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let s;if(a==="dir"){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if(a==="ECDH-ES"&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");let o;{let y;({cek:o,encryptedKey:s,parameters:y}=await encryptKeyManagement(a,i,t,this._cek,this._keyManagementParameters)),y&&(r&&Ie in r?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...y}:this.setUnprotectedHeader(y):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...y}:this.setProtectedHeader(y))}this._iv||(this._iv=generateIv(i));let d,c,l;this._protectedHeader?c=encoder.encode(base64url(JSON.stringify(this._protectedHeader))):c=encoder.encode(""),this._aad?(l=base64url(this._aad),d=concat(c,encoder.encode("."),encoder.encode(l))):d=c;let u,p;if(n.zip==="DEF"){const y=await(r?.deflateRaw||deflate)(this._plaintext);({ciphertext:u,tag:p}=await encrypt(i,y,o,this._iv,d))}else({ciphertext:u,tag:p}=await encrypt(i,this._plaintext,o,this._iv,d));const h={ciphertext:base64url(u),iv:base64url(this._iv),tag:base64url(p)};return s&&(h.encrypted_key=base64url(s)),l&&(h.aad=l),this._protectedHeader&&(h.protected=decoder.decode(c)),this._sharedUnprotectedHeader&&(h.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(h.header=this._unprotectedHeader),h}}class Pe{constructor(t,r,n){this.parent=t,this.key=r,this.options=n}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addRecipient(...t){return this.parent.addRecipient(...t)}encrypt(...t){return this.parent.encrypt(...t)}done(){return this.parent}}class fr{constructor(t){this._recipients=[],this._plaintext=t}addRecipient(t,r){const n=new Pe(this,t,{crit:r?.crit});return this._recipients.push(n),n}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setSharedUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}setAdditionalAuthenticatedData(t){return this._aad=t,this}async encrypt(t){var r,n,a;if(!this._recipients.length)throw new JWEInvalid("at least one recipient must be added");if(t={deflateRaw:t?.deflateRaw},this._recipients.length===1){const[d]=this._recipients,c=await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(d.unprotectedHeader).encrypt(d.key,{...d.options,...t});let l={ciphertext:c.ciphertext,iv:c.iv,recipients:[{}],tag:c.tag};return c.aad&&(l.aad=c.aad),c.protected&&(l.protected=c.protected),c.unprotected&&(l.unprotected=c.unprotected),c.encrypted_key&&(l.recipients[0].encrypted_key=c.encrypted_key),c.header&&(l.recipients[0].header=c.header),l}let i;for(let d=0;d<this._recipients.length;d++){const c=this._recipients[d];if(!isDisjoint(this._protectedHeader,this._unprotectedHeader,c.unprotectedHeader))throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const l={...this._protectedHeader,...this._unprotectedHeader,...c.unprotectedHeader},{alg:u}=l;if(typeof u!="string"||!u)throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(u==="dir"||u==="ECDH-ES")throw new JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');if(typeof l.enc!="string"||!l.enc)throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(!i)i=l.enc;else if(i!==l.enc)throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');if(validateCrit(JWEInvalid,new Map,c.options.crit,this._protectedHeader,l),l.zip!==void 0&&(!this._protectedHeader||!this._protectedHeader.zip))throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected')}const s=generateCek(i);let o={ciphertext:"",iv:"",recipients:[],tag:""};for(let d=0;d<this._recipients.length;d++){const c=this._recipients[d],l={};o.recipients.push(l);const p={...this._protectedHeader,...this._unprotectedHeader,...c.unprotectedHeader}.alg.startsWith("PBES2")?2048+d:void 0;if(d===0){const f=await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(s).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(c.unprotectedHeader).setKeyManagementParameters({p2c:p}).encrypt(c.key,{...c.options,...t,[unprotected]:!0});o.ciphertext=f.ciphertext,o.iv=f.iv,o.tag=f.tag,f.aad&&(o.aad=f.aad),f.protected&&(o.protected=f.protected),f.unprotected&&(o.unprotected=f.unprotected),l.encrypted_key=f.encrypted_key,f.header&&(l.header=f.header);continue}const{encryptedKey:h,parameters:y}=await encryptKeyManagement(((r=c.unprotectedHeader)===null||r===void 0?void 0:r.alg)||((n=this._protectedHeader)===null||n===void 0?void 0:n.alg)||((a=this._unprotectedHeader)===null||a===void 0?void 0:a.alg),i,c.key,s,{p2c:p});l.encrypted_key=base64url(h),(c.unprotectedHeader||y)&&(l.header={...c.unprotectedHeader,...y})}return o}}function Te(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new G(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}const wr=async(e,t,r,n)=>{const a=await getVerifyKey(e,t,"verify");checkKeyLength(e,a);const i=subtleAlgorithm(e,a.algorithm);try{return await crypto.subtle.verify(i,a,r,n)}catch{return!1}},mr=null;async function Er(e,t,r){var n;if(!isObject(e))throw new JWSInvalid("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new JWSInvalid("JWS Protected Header incorrect type");if(e.payload===void 0)throw new JWSInvalid("JWS Payload missing");if(typeof e.signature!="string")throw new JWSInvalid("JWS Signature missing or incorrect type");if(e.header!==void 0&&!isObject(e.header))throw new JWSInvalid("JWS Unprotected Header incorrect type");let a={};if(e.protected)try{const S=base64url(e.protected);a=JSON.parse(decoder.decode(S))}catch{throw new JWSInvalid("JWS Protected Header is invalid")}if(!isDisjoint(a,e.header))throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...a,...e.header},s=validateCrit(JWSInvalid,new Map([["b64",!0]]),r?.crit,a,i);let o=!0;if(s.has("b64")&&(o=a.b64,typeof o!="boolean"))throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:d}=i;if(typeof d!="string"||!d)throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');const c=r&&validateAlgorithms("algorithms",r.algorithms);if(c&&!c.has(d))throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');if(o){if(typeof e.payload!="string")throw new JWSInvalid("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");let l=!1;typeof t=="function"&&(t=await t(a,e),l=!0),checkKeyType(d,t,"verify");const u=concat(encoder.encode((n=e.protected)!==null&&n!==void 0?n:""),encoder.encode("."),typeof e.payload=="string"?encoder.encode(e.payload):e.payload);let p;try{p=base64url(e.signature)}catch{throw new JWSInvalid("Failed to base64url decode the signature")}if(!await verify(d,t,p,u))throw new JWSSignatureVerificationFailed;let y;if(o)try{y=base64url(e.payload)}catch{throw new JWSInvalid("Failed to base64url decode the payload")}else typeof e.payload=="string"?y=encoder.encode(e.payload):y=e.payload;const f={payload:y};return e.protected!==void 0&&(f.protectedHeader=a),e.header!==void 0&&(f.unprotectedHeader=e.header),l?{...f,key:t}:f}async function Sr(e,t,r){if(e instanceof Uint8Array&&(e=decoder.decode(e)),typeof e!="string")throw new JWSInvalid("Compact JWS must be a string or Uint8Array");const{0:n,1:a,2:i,length:s}=e.split(".");if(s!==3)throw new JWSInvalid("Invalid Compact JWS");const o=await flattenedVerify({payload:a,protected:n,signature:i},t,r),d={payload:o.payload,protectedHeader:o.protectedHeader};return typeof t=="function"?{...d,key:o.key}:d}async function gr(e,t,r){if(!isObject(e))throw new JWSInvalid("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(isObject))throw new JWSInvalid("JWS Signatures missing or incorrect type");for(const n of e.signatures)try{return await flattenedVerify({header:n.header,payload:e.payload,protected:n.protected,signature:n.signature},t,r)}catch{}throw new JWSSignatureVerificationFailed}const te=60,re=te*60,D=re*24,Oe=D*7,xe=D*365.25,Re=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i,ne=e=>{const t=Re.exec(e);if(!t)throw new TypeError("Invalid time period format");const r=parseFloat(t[1]);switch(t[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(r*te);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(r*re);case"day":case"days":case"d":return Math.round(r*D);case"week":case"weeks":case"w":return Math.round(r*Oe);default:return Math.round(r*xe)}},ae=e=>e.toLowerCase().replace(/^application\//,""),Ue=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):!1,_r=(e,t,r={})=>{const{typ:n}=r;if(n&&(typeof e.typ!="string"||ae(e.typ)!==ae(n)))throw new JWTClaimValidationFailed('unexpected "typ" JWT header value',"typ","check_failed");let a;try{a=JSON.parse(decoder.decode(t))}catch{}if(!isObject(a))throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");const{requiredClaims:i=[],issuer:s,subject:o,audience:d,maxTokenAge:c}=r;c!==void 0&&i.push("iat"),d!==void 0&&i.push("aud"),o!==void 0&&i.push("sub"),s!==void 0&&i.push("iss");for(const h of new Set(i.reverse()))if(!(h in a))throw new JWTClaimValidationFailed(`missing required "${h}" claim`,h,"missing");if(s&&!(Array.isArray(s)?s:[s]).includes(a.iss))throw new JWTClaimValidationFailed('unexpected "iss" claim value',"iss","check_failed");if(o&&a.sub!==o)throw new JWTClaimValidationFailed('unexpected "sub" claim value',"sub","check_failed");if(d&&!Ue(a.aud,typeof d=="string"?[d]:d))throw new JWTClaimValidationFailed('unexpected "aud" claim value',"aud","check_failed");let l;switch(typeof r.clockTolerance){case"string":l=secs(r.clockTolerance);break;case"number":l=r.clockTolerance;break;case"undefined":l=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:u}=r,p=epoch(u||new Date);if((a.iat!==void 0||c)&&typeof a.iat!="number")throw new JWTClaimValidationFailed('"iat" claim must be a number',"iat","invalid");if(a.nbf!==void 0){if(typeof a.nbf!="number")throw new JWTClaimValidationFailed('"nbf" claim must be a number',"nbf","invalid");if(a.nbf>p+l)throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed',"nbf","check_failed")}if(a.exp!==void 0){if(typeof a.exp!="number")throw new JWTClaimValidationFailed('"exp" claim must be a number',"exp","invalid");if(a.exp<=p-l)throw new JWTExpired('"exp" claim timestamp check failed',"exp","check_failed")}if(c){const h=p-a.iat,y=typeof c=="number"?c:secs(c);if(h-l>y)throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(h<0-l)throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return a};async function br(e,t,r){var n;const a=await compactVerify(e,t,r);if(!((n=a.protectedHeader.crit)===null||n===void 0)&&n.includes("b64")&&a.protectedHeader.b64===!1)throw new JWTInvalid("JWTs MUST NOT use unencoded payload");const s={payload:jwtPayload(a.protectedHeader,a.payload,r),protectedHeader:a.protectedHeader};return typeof t=="function"?{...s,key:a.key}:s}async function Ar(e,t,r){const n=await compactDecrypt(e,t,r),a=jwtPayload(n.protectedHeader,n.plaintext,r),{protectedHeader:i}=n;if(i.iss!==void 0&&i.iss!==a.iss)throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch',"iss","mismatch");if(i.sub!==void 0&&i.sub!==a.sub)throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch',"sub","mismatch");if(i.aud!==void 0&&JSON.stringify(i.aud)!==JSON.stringify(a.aud))throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch',"aud","mismatch");const s={payload:a,protectedHeader:i};return typeof t=="function"?{...s,key:n.key}:s}class vr{constructor(t){this._flattened=new FlattenedEncrypt(t)}setContentEncryptionKey(t){return this._flattened.setContentEncryptionKey(t),this}setInitializationVector(t){return this._flattened.setInitializationVector(t),this}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}setKeyManagementParameters(t){return this._flattened.setKeyManagementParameters(t),this}async encrypt(t,r){const n=await this._flattened.encrypt(t,r);return[n.protected,n.encrypted_key,n.iv,n.ciphertext,n.tag].join(".")}}const De=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function w(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function b(e,t){return e.name===t}function O(e){return parseInt(e.name.slice(4),10)}function Me(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function ie(e,t){if(t.length&&!t.some(r=>e.usages.includes(r))){let r="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const n=t.pop();r+=`one of ${t.join(", ")}, or ${n}.`}else t.length===2?r+=`one of ${t[0]} or ${t[1]}.`:r+=`${t[0]}.`;throw new TypeError(r)}}function ke(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!b(e.algorithm,"HMAC"))throw w("HMAC");const n=parseInt(t.slice(2),10);if(O(e.algorithm.hash)!==n)throw w(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!b(e.algorithm,"RSASSA-PKCS1-v1_5"))throw w("RSASSA-PKCS1-v1_5");const n=parseInt(t.slice(2),10);if(O(e.algorithm.hash)!==n)throw w(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!b(e.algorithm,"RSA-PSS"))throw w("RSA-PSS");const n=parseInt(t.slice(2),10);if(O(e.algorithm.hash)!==n)throw w(`SHA-${n}`,"algorithm.hash");break}case"EdDSA":{if(e.algorithm.name!=="Ed25519"&&e.algorithm.name!=="Ed448")throw w("Ed25519 or Ed448");break}case"ES256":case"ES384":case"ES512":{if(!b(e.algorithm,"ECDSA"))throw w("ECDSA");const n=Me(t);if(e.algorithm.namedCurve!==n)throw w(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}ie(e,r)}function Jr(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!b(e.algorithm,"AES-GCM"))throw w("AES-GCM");const n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw w(n,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!b(e.algorithm,"AES-KW"))throw w("AES-KW");const n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw w(n,"algorithm.length");break}case"ECDH":{switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw w("ECDH, X25519, or X448")}break}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!b(e.algorithm,"PBKDF2"))throw w("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!b(e.algorithm,"RSA-OAEP"))throw w("RSA-OAEP");const n=parseInt(t.slice(9),10)||1;if(O(e.algorithm.hash)!==n)throw w(`SHA-${n}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}ie(e,r)}function se(e,t,...r){if(r.length>2){const n=r.pop();e+=`one of type ${r.join(", ")}, or ${n}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&t.constructor&&t.constructor.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const oe=(e,...t)=>se("Key must be ",e,...t);function ce(e,t,...r){return se(`Key for the ${e} algorithm must be `,t,...r)}const de=e=>V(e),E=["CryptoKey"];function Ne(e,t,r){if(V(t))return ke(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(oe(t,...E));return T.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(oe(t,...E,"Uint8Array"))}const Le=async(e,t,r)=>{const n=await Ne(e,t,"sign");De(e,n);const a=await T.subtle.sign(Te(e,n.algorithm),n,r);return new Uint8Array(a)},Be=(...e)=>{const t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(const n of t){const a=Object.keys(n);if(!r||r.size===0){r=new Set(a);continue}for(const i of a){if(r.has(i))return!1;r.add(i)}}return!0},Fe=(e,t)=>{if(!(t instanceof Uint8Array)){if(!de(t))throw new TypeError(ce(e,t,...E,"Uint8Array"));if(t.type!=="secret")throw new TypeError(`${E.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}},$e=(e,t,r)=>{if(!de(t))throw new TypeError(ce(e,t,...E));if(t.type==="secret")throw new TypeError(`${E.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if(r==="sign"&&t.type==="public")throw new TypeError(`${E.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if(r==="decrypt"&&t.type==="public")throw new TypeError(`${E.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&r==="verify"&&t.type==="private")throw new TypeError(`${E.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&r==="encrypt"&&t.type==="private")throw new TypeError(`${E.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)},Ge=(e,t,r)=>{e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?Fe(e,t):$e(e,t,r)};class Ve{constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=t}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}async sign(t,r){if(!this._protectedHeader&&!this._unprotectedHeader)throw new I("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!Be(this._protectedHeader,this._unprotectedHeader))throw new I("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const n={...this._protectedHeader,...this._unprotectedHeader},a=He(I,new Map([["b64",!0]]),r?.crit,this._protectedHeader,n);let i=!0;if(a.has("b64")&&(i=this._protectedHeader.b64,typeof i!="boolean"))throw new I('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=n;if(typeof s!="string"||!s)throw new I('JWS "alg" (Algorithm) Header Parameter missing or invalid');Ge(s,t,"sign");let o=this._payload;i&&(o=g.encode(P(o)));let d;this._protectedHeader?d=g.encode(P(JSON.stringify(this._protectedHeader))):d=g.encode("");const c=C(d,g.encode("."),o),l=await Le(s,t,c),u={signature:P(l),payload:""};return i&&(u.payload=J.decode(o)),this._unprotectedHeader&&(u.header=this._unprotectedHeader),this._protectedHeader&&(u.protected=J.decode(d)),u}}class ze{constructor(t){this._flattened=new Ve(t)}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}async sign(t,r){const n=await this._flattened.sign(t,r);if(n.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${n.protected}.${n.payload}.${n.signature}`}}class Xe{constructor(t,r,n){this.parent=t,this.key=r,this.options=n}setProtectedHeader(t){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=t,this}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addSignature(...t){return this.parent.addSignature(...t)}sign(...t){return this.parent.sign(...t)}done(){return this.parent}}class Hr{constructor(t){this._signatures=[],this._payload=t}addSignature(t,r){const n=new Xe(this,t,r);return this._signatures.push(n),n}async sign(){if(!this._signatures.length)throw new JWSInvalid("at least one signature must be added");const t={signatures:[],payload:""};for(let r=0;r<this._signatures.length;r++){const n=this._signatures[r],a=new FlattenedSign(this._payload);a.setProtectedHeader(n.protectedHeader),a.setUnprotectedHeader(n.unprotectedHeader);const{payload:i,...s}=await a.sign(n.key,n.options);if(r===0)t.payload=i;else if(t.payload!==i)throw new JWSInvalid("inconsistent use of JWS Unencoded Payload (RFC7797)");t.signatures.push(s)}return t}}const M=e=>Math.floor(e.getTime()/1e3);function Ye(e){return typeof e=="object"&&e!==null}function Ze(e){if(!Ye(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}class qe{constructor(t){if(!Ze(t))throw new TypeError("JWT Claims Set MUST be an object");this._payload=t}setIssuer(t){return this._payload={...this._payload,iss:t},this}setSubject(t){return this._payload={...this._payload,sub:t},this}setAudience(t){return this._payload={...this._payload,aud:t},this}setJti(t){return this._payload={...this._payload,jti:t},this}setNotBefore(t){return typeof t=="number"?this._payload={...this._payload,nbf:t}:this._payload={...this._payload,nbf:M(new Date)+ne(t)},this}setExpirationTime(t){return typeof t=="number"?this._payload={...this._payload,exp:t}:this._payload={...this._payload,exp:M(new Date)+ne(t)},this}setIssuedAt(t){return typeof t>"u"?this._payload={...this._payload,iat:M(new Date)}:this._payload={...this._payload,iat:t},this}}class Qe extends qe{setProtectedHeader(t){return this._protectedHeader=t,this}async sign(t,r){var n;const a=new ze(g.encode(JSON.stringify(this._payload)));if(a.setProtectedHeader(this._protectedHeader),Array.isArray((n=this._protectedHeader)===null||n===void 0?void 0:n.crit)&&this._protectedHeader.crit.includes("b64")&&this._protectedHeader.b64===!1)throw new we("JWTs MUST NOT use unencoded payload");return a.sign(t,r)}}class Ir extends null{setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setKeyManagementParameters(t){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=t,this}setContentEncryptionKey(t){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=t,this}setInitializationVector(t){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=t,this}replicateIssuerAsHeader(){return this._replicateIssuerAsHeader=!0,this}replicateSubjectAsHeader(){return this._replicateSubjectAsHeader=!0,this}replicateAudienceAsHeader(){return this._replicateAudienceAsHeader=!0,this}async encrypt(t,r){const n=new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));return this._replicateIssuerAsHeader&&(this._protectedHeader={...this._protectedHeader,iss:this._payload.iss}),this._replicateSubjectAsHeader&&(this._protectedHeader={...this._protectedHeader,sub:this._payload.sub}),this._replicateAudienceAsHeader&&(this._protectedHeader={...this._protectedHeader,aud:this._payload.aud}),n.setProtectedHeader(this._protectedHeader),this._iv&&n.setInitializationVector(this._iv),this._cek&&n.setContentEncryptionKey(this._cek),this._keyManagementParameters&&n.setKeyManagementParameters(this._keyManagementParameters),n.encrypt(t,r)}}const A=(e,t)=>{if(typeof e!="string"||!e)throw new JWKInvalid(`${t} missing or invalid`)};async function je(e,t){if(!isObject(e))throw new TypeError("JWK must be an object");if(t??(t="sha256"),t!=="sha256"&&t!=="sha384"&&t!=="sha512")throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');let r;switch(e.kty){case"EC":A(e.crv,'"crv" (Curve) Parameter'),A(e.x,'"x" (X Coordinate) Parameter'),A(e.y,'"y" (Y Coordinate) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":A(e.crv,'"crv" (Subtype of Key Pair) Parameter'),A(e.x,'"x" (Public Key) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":A(e.e,'"e" (Exponent) Parameter'),A(e.n,'"n" (Modulus) Parameter'),r={e:e.e,kty:e.kty,n:e.n};break;case"oct":A(e.k,'"k" (Key Value) Parameter'),r={k:e.k,kty:e.kty};break;default:throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported')}const n=encoder.encode(JSON.stringify(r));return base64url(await digest(t,n))}async function Pr(e,t){t??(t="sha256");const r=await je(e,t);return`urn:ietf:params:oauth:jwk-thumbprint:sha-${t.slice(-3)}:${r}`}async function Tr(e,t){const r={...e,...t?.header};if(!isObject(r.jwk))throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');const n=await importJWK({...r.jwk,ext:!0},r.alg,!0);if(n instanceof Uint8Array||n.type!=="public")throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');return n}function et(e){switch(typeof e=="string"&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set')}}function tt(e){return e&&typeof e=="object"&&Array.isArray(e.keys)&&e.keys.every(rt)}function rt(e){return isObject(e)}function nt(e){return typeof structuredClone=="function"?structuredClone(e):JSON.parse(JSON.stringify(e))}class at{constructor(t){if(this._cached=new WeakMap,!tt(t))throw new JWKSInvalid("JSON Web Key Set malformed");this._jwks=nt(t)}async getKey(t,r){const{alg:n,kid:a}={...t,...r?.header},i=et(n),s=this._jwks.keys.filter(c=>{let l=i===c.kty;if(l&&typeof a=="string"&&(l=a===c.kid),l&&typeof c.alg=="string"&&(l=n===c.alg),l&&typeof c.use=="string"&&(l=c.use==="sig"),l&&Array.isArray(c.key_ops)&&(l=c.key_ops.includes("verify")),l&&n==="EdDSA"&&(l=c.crv==="Ed25519"||c.crv==="Ed448"),l)switch(n){case"ES256":l=c.crv==="P-256";break;case"ES256K":l=c.crv==="secp256k1";break;case"ES384":l=c.crv==="P-384";break;case"ES512":l=c.crv==="P-521";break}return l}),{0:o,length:d}=s;if(d===0)throw new JWKSNoMatchingKey;if(d!==1){const c=new JWKSMultipleMatchingKeys,{_cached:l}=this;throw c[Symbol.asyncIterator]=async function*(){for(const u of s)try{yield await le(l,u,n)}catch{continue}},c}return le(this._cached,o,n)}}async function le(e,t,r){const n=e.get(t)||e.set(t,{}).get(t);if(n[r]===void 0){const a=await importJWK({...t,ext:!0},r);if(a instanceof Uint8Array||a.type!=="public")throw new JWKSInvalid("JSON Web Key Set members must be public keys");n[r]=a}return n[r]}function Or(e){const t=new at(e);return async function(r,n){return t.getKey(r,n)}}const xr=async(e,t,r)=>{let n,a,i=!1;typeof AbortController=="function"&&(n=new AbortController,a=setTimeout(()=>{i=!0,n.abort()},t));const s=await fetch(e.href,{signal:n?n.signal:void 0,redirect:"manual",headers:r.headers}).catch(o=>{throw i?new JWKSTimeout:o});if(a!==void 0&&clearTimeout(a),s.status!==200)throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await s.json()}catch{throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON")}},Rr=null;function it(){return typeof WebSocketPair<"u"||typeof navigator<"u"&&navigator.userAgent==="Cloudflare-Workers"||typeof EdgeRuntime<"u"&&EdgeRuntime==="vercel"}class st extends null{constructor(t,r){if(super({keys:[]}),this._jwks=void 0,!(t instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(t.href),this._options={agent:r?.agent,headers:r?.headers},this._timeoutDuration=typeof r?.timeoutDuration=="number"?r?.timeoutDuration:5e3,this._cooldownDuration=typeof r?.cooldownDuration=="number"?r?.cooldownDuration:3e4,this._cacheMaxAge=typeof r?.cacheMaxAge=="number"?r?.cacheMaxAge:6e5}coolingDown(){return typeof this._jwksTimestamp=="number"?Date.now()<this._jwksTimestamp+this._cooldownDuration:!1}fresh(){return typeof this._jwksTimestamp=="number"?Date.now()<this._jwksTimestamp+this._cacheMaxAge:!1}async getKey(t,r){(!this._jwks||!this.fresh())&&await this.reload();try{return await super.getKey(t,r)}catch(n){if(n instanceof JWKSNoMatchingKey&&this.coolingDown()===!1)return await this.reload(),super.getKey(t,r);throw n}}async reload(){this._pendingFetch&&it()&&(this._pendingFetch=void 0),this._pendingFetch||(this._pendingFetch=fetchJwks(this._url,this._timeoutDuration,this._options).then(t=>{if(!isJWKSLike(t))throw new JWKSInvalid("JSON Web Key Set malformed");this._jwks={keys:t.keys},this._jwksTimestamp=Date.now(),this._pendingFetch=void 0}).catch(t=>{throw this._pendingFetch=void 0,t})),await this._pendingFetch}}function Ur(e,t){const r=new st(e,t);return async function(n,a){return r.getKey(n,a)}}class Dr extends null{encode(){const t=base64url.encode(JSON.stringify({alg:"none"})),r=base64url.encode(JSON.stringify(this._payload));return`${t}.${r}.`}static decode(t,r){if(typeof t!="string")throw new JWTInvalid("Unsecured JWT must be a string");const{0:n,1:a,2:i,length:s}=t.split(".");if(s!==3||i!=="")throw new JWTInvalid("Invalid Unsecured JWT");let o;try{if(o=JSON.parse(decoder.decode(base64url.decode(n))),o.alg!=="none")throw new Error}catch{throw new JWTInvalid("Invalid Unsecured JWT")}return{payload:jwtPayload(o,base64url.decode(a),r),header:o}}}const Mr=P,kr=fe;function Nr(e){let t;if(typeof e=="string"){const r=e.split(".");(r.length===3||r.length===5)&&([t]=r)}else if(typeof e=="object"&&e)if("protected"in e)t=e.protected;else throw new TypeError("Token does not contain a Protected Header");try{if(typeof t!="string"||!t)throw new Error;const r=JSON.parse(decoder.decode(base64url(t)));if(!isObject(r))throw new Error;return r}catch{throw new TypeError("Invalid Token or Protected Header formatting")}}function Lr(e){if(typeof e!="string")throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");const{1:t,length:r}=e.split(".");if(r===5)throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");if(r!==3)throw new JWTInvalid("Invalid JWT");if(!t)throw new JWTInvalid("JWTs must contain a payload");let n;try{n=base64url(t)}catch{throw new JWTInvalid("Failed to base64url decode the payload")}let a;try{a=JSON.parse(decoder.decode(n))}catch{throw new JWTInvalid("Failed to parse the decoded payload as JSON")}if(!isObject(a))throw new JWTInvalid("Invalid JWT Claims Set");return a}async function Br(e,t){var r;let n,a,i;switch(e){case"HS256":case"HS384":case"HS512":n=parseInt(e.slice(-3),10),a={name:"HMAC",hash:`SHA-${n}`,length:n},i=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return n=parseInt(e.slice(-3),10),random(new Uint8Array(n>>3));case"A128KW":case"A192KW":case"A256KW":n=parseInt(e.slice(1,4),10),a={name:"AES-KW",length:n},i=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":n=parseInt(e.slice(1,4),10),a={name:"AES-GCM",length:n},i=["encrypt","decrypt"];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return crypto.subtle.generateKey(a,(r=t?.extractable)!==null&&r!==void 0?r:!1,i)}function k(e){var t;const r=(t=e?.modulusLength)!==null&&t!==void 0?t:2048;if(typeof r!="number"||r<2048)throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return r}async function Fr(e,t){var r,n,a;let i,s;switch(e){case"PS256":case"PS384":case"PS512":i={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:k(t)},s=["sign","verify"];break;case"RS256":case"RS384":case"RS512":i={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:k(t)},s=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":i={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:k(t)},s=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":i={name:"ECDSA",namedCurve:"P-256"},s=["sign","verify"];break;case"ES384":i={name:"ECDSA",namedCurve:"P-384"},s=["sign","verify"];break;case"ES512":i={name:"ECDSA",namedCurve:"P-521"},s=["sign","verify"];break;case"EdDSA":s=["sign","verify"];const o=(r=t?.crv)!==null&&r!==void 0?r:"Ed25519";switch(o){case"Ed25519":case"Ed448":i={name:o};break;default:throw new JOSENotSupported("Invalid or unsupported crv option provided")}break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{s=["deriveKey","deriveBits"];const d=(n=t?.crv)!==null&&n!==void 0?n:"P-256";switch(d){case"P-256":case"P-384":case"P-521":{i={name:"ECDH",namedCurve:d};break}case"X25519":case"X448":i={name:d};break;default:throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return crypto.subtle.generateKey(i,(a=t?.extractable)!==null&&a!==void 0?a:!1,s)}async function $r(e,t){return generate(e,t)}async function Gr(e,t){return generate(e,t)}}}]);

//# sourceMappingURL=/619.45fc602bd18af0286d6f.chunk.js.map